1)Write a C program to illustrate the concept of orphan process. Parent process 
creates a child and terminates before child has finished its task. So child process 
becomes orphan process. (Use fork(), sleep(), getpid(), getppid()).
Ans:
#include <stdio.h>
#include <unistd.h>
int main() {
 int pid = fork();
 if (pid > 0) {
 printf("Parent PID: %d\n", getpid());
 sleep(2);
 printf("Parent ends\n");
 } 
 else {
 sleep(5);
 printf("Child PID: %d, Parent PID: %d\n", getpid(), getppid());
 printf("Child became orphan\n");
 }
 return 0;
}
2)Write the simulation program to implement demand paging and show the page 
scheduling and total number of page faults for the following given page reference 
string. Give input n as the number of memory frames. Reference String: 
2,5,2,8,5,4,1,2,3,2,6,1,2,5,9,8 
1)LRU 
Ans:
#include <stdio.h>
int main() {
 int frames[10], last[10], n, i, j, pageFaults=0, pos;
 int ref[16]={2,5,2,8,5,4,1,2,3,2,6,1,2,5,9,8};
 
 printf("Enter number of frames: ");
 scanf("%d",&n);
 for(i=0;i<n;i++){ frames[i]=-1; last[i]=-1; }
 printf("Ref\tFrames\tFault\n");
 for(i=0;i<16;i++){
 int found=0;
 for(j=0;j<n;j++)
 if(frames[j]==ref[i]){ found=1; last[j]=i; break; }
 if(!found){
 pageFaults++;
 int empty=-1;
 for(j=0;j<n;j++) if(frames[j]==-1){ empty=j; break; }
 if(empty!=-1){ frames[empty]=ref[i]; last[empty]=i; }
 else{
 int min=last[0]; pos=0;
 for(j=1;j<n;j++) if(last[j]<min){ min=last[j]; pos=j; }
 frames[pos]=ref[i]; last[pos]=i;
 }
 }
 printf("%d\t",ref[i]);
 for(j=0;j<n;j++) if(frames[j]!=-1) printf("%d ",frames[j]);
 printf("\t%s\n",found?"No":"Yes");
 }
 printf("Total Page Faults=%d\n",pageFaults);
 return 0;
}